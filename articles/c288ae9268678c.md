---
title: "初心者がGitを学んでみた"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Git", "初心者"]
published: false
---

# 学習の経緯
個人開発でバージョン管理に困っていたので、Gitについて学習しました。
また、Recursionというオンラインサービスでも学習をしており、そこでもGitを学んだため自分なりにまとめてみようと思います。


# Gitとは
ソースコードのバージョンを管理するオープンソースのツールです。
https://git-scm.com/about
ソースコードの変更履歴などすべてをリポジトリで管理します。
複数のPCで作業していたとしても、GitHubのような管理ツールを使うことでローカルのリポジトリの情報をサーバーにアップロードして管理することができます。


Gitは基本的に、その時の全てのファイルの状態のスナップショットを撮り（訳者注：意訳）、そのスナップショットへの参照を格納するのです。 効率化のため、ファイルに変更が無い場合は、Gitはファイルを再格納せず、既に格納してある、以前の同一のファイルへのリンクを格納します。 Gitは、むしろデータを*一連のスナップショット*のように考えます。


# 3つの状態
![](/images/areas.png)
開発を行う際、ローカルのPC上ではファイルは「Working Directory」として存在しています。
ファイルに何かした変更があった場合には「Staging Area」にあげます。
ステージングエリアに上げたら、コミットすることでそのファイルをリポジトリに格納することができます。

リポジトリにあるファイルはブランチで管理されており、コミットの履歴をたどることができます。
このようにGitで管理することで、以前のコミット履歴にバージョンを戻すことが可能です。

# ファイルの状態
![](/images/lifecycle.png)
さらに詳細を見るとただ既存のファイルに変更を加えた場合と新規ファイルを作成した場合でコマンドなどの使い方が変わってきます。
- 新規ファイルを作成した場合
この場合はuntracked（未追跡）となり、gitがバージョンを管理できていません。
一度ステージングエリアにあげて追跡可能な状態にする必要があります。

- ファイルの変更を行った場合
一度コミットしているので、ファイルの変更部分が管理されます。

## ファイル変更の検知
Gitでは内部で「チェックサム」が使用されています。
チェックサムとは、データが送受信時や保存時に破損したり改ざんされたりしていないかを確認するために算出される「検証値」のことです。
チェックサムを使うことでファイルの変更点やファイルが破損していないかを検知します。
https://grokipedia.com/page/Checksum
具体的には「SHA-1ハッシュ」が使用されており、16進数の文字が40文字（20バイト）並んでいます。
```
24b9da6552252987aa493b52f8696cd6d3b00373
```
Gitではコミット名にこのようなハッシュ値が使用されており、その名称を追跡します。


## 確認方法
以下のコマンドで簡単にファイルの状態を確認することができます。
```bash
git status
```

- 新規ファイルを作成した場合（未追跡）
```bash
 echo 'My Project' > README
 git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```

- ファイルの変更のみ行った場合
```bash
 git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```

## addとcommit
「add」と「commit」についていまいち違いが分からないというか、ステージング（git add）の必要性が分からないというのが正直なところです。なぜファイルをステージングエリアに追加する必要があるのでしょうか。
ステージングとは、作業ディレクトリの変更を「次のコミットに含める操作」として登録する操作です。
つまり、このような表現で例えることができます。
:::message
「カゴに商品を入れる（add）」 → 「レジで会計する（commit）」
:::


# 基本的なコマンドのまとめ
```bash
#外部URLからリポジトリを複製
 git clone [URL]

#ローカルにリポジトリ作成
 git init

#ステージングエリアに追加
 git add [file名]

#コミット
 git commit  # git commit -m "コメント"

#GitHubリポジトリにPush
 git push
```

# 前回のコミット履歴に戻る場合
作業していて、前回のコミット履歴に戻りたい時に困ったことがありました。
Untrackedファイル（新規追加したファイル）と編集したファイルの両方がコミットされていない場合、一旦新規追加したファイルを削除した後コミット履歴を戻す必要があることがわかりました。

```bash
#ステータスの確認
git status

# Untrackedファイルを削除
git clean -df

# Staged/Modified状態の変更を破棄し、HEADを現在のコミットにリセット
# （結果として、作業ディレクトリが直近のコミット時点の状態になる）
git reset --hard HEAD
```

:::message alert
注意: `git clean -df` と `git reset --hard` は取り消しできない破壊的操作です。実行前に変更のバックアップやブランチを作成してください。
:::

git clean コマンドは、Gitで追跡されていないファイルを作業ディレクトリから削除します。
-d: ディレクトリも削除対象に含めます。
-f: 強制的に削除を実行します (確認メッセージなし)。

git reset --hard コマンドは、作業ツリー、インデックス（ステージングエリア）、およびHEADを指定されたコミット時点の状態に完全にリセットします。前回のコミットに戻る場合は HEAD^ または HEAD~1 を指定します。

## 推奨のやり方（目的別）

- 公開ブランチで履歴を壊さずに戻したい（おすすめ）
  - `git revert HEAD` で「直前のコミットを打ち消す新しいコミット」を作る。
  - 例:
    ```bash
    git revert HEAD
    git push
    ```

- まだ push していない直前のコミットを作り直したい
  - 変更を保持したまま一つ前に戻す: `git reset --soft HEAD^` → 再度 `git commit`
  - 単に直前のコミット内容やメッセージを修正するだけなら: `git commit --amend`
  - 例:
    ```bash
    # 変更はステージされた状態で残る
    git reset --soft HEAD^
    git commit -m "やり直しのコミット"
    ```

- 作業ツリーの変更だけ捨てたい／ステージ解除したい
  - 作業ツリーの変更を破棄: `git restore <file>` または `git restore .`
  - ステージ解除: `git restore --staged <file>`
  - 一時退避（未追跡も含める）: `git stash -u`

- 未追跡ファイルの削除はプレビューしてから
  - 実行前に確認: `git clean -dfn`（dry-run）

補足: `HEAD^` と `HEAD~1` はどちらも「一つ前のコミット」を指します。

# チェックアウト
`git switch`（推奨）や `git checkout` でブランチ間を移動できます。

## ブランチについて
ここからはもう少しブランチについて学び、より良い管理を行えるようにしていきます。
ブランチは「コミット列の先頭」を指すラベルで、HEADは「いま作業中のブランチ」を指すポインタです。
この関係を理解すると仕組みが掴みやすくなります。
```bash
git init
```
リポジトリ作成直後、HEADポインタはデフォルトブランチ（一般的に `main`）を指します。
新規でブランチを作成しましょう。
```bash
# 新しいブランチを作って切り替え（推奨）
git switch -c feature/awesome

# 既存ブランチに切り替え
git switch feature/awesome

# 互換コマンド（昔からある書き方）
git checkout -b feature/awesome   # 作成 + 切替
git checkout feature/awesome      # 切替
```
この時点でブランチは作成できましたが、切り替えていなければHEADは `main` を指したままです。
![](/images/head-to-master.png)

つまり、HEADポインタが指し示しているブランチに対してGitコマンドの操作が反映されます。ブランチを切り替えると、HEADはそのブランチを指すようになります。
```bash
git switch feature/awesome
```
![](/images/checkout-master.png)

# マージ
複数のブランチをマージすることができます。基本は、作業ブランチ（例: `feature/awesome`）をメインブランチ（`main`）へ取り込む操作です。

## マージの種類
- Fast-forward（早送り）: `main` が分岐後に進んでいなければ、ポインタを前に進めるだけの単純な取り込みになります。
  ```bash
  git switch main
  git merge --ff-only feature/awesome
  ```
- マージコミット: `main` も進んでいる場合は、分岐を一つにまとめるコミットを作ります。
  ```bash
  git switch main
  git merge feature/awesome           # 必要に応じて --no-ff
  ```

## コンフリクトが起きたら
1. 競合ファイルをエディタで解消（`<<<<<<` `======` `>>>>>>` の印を編集）
2. 解消したファイルをステージ
   ```bash
   git add <file>
   ```
3. マージを完了
   ```bash
   git commit   # マージコミットが作成される
   ```

:::message
TIP: チーム運用では、履歴をシンプルにしたい場合「Squash merge（PR側設定）」や「Fast-forward only」を使うことが多いです。
:::

# Gitサーバー（リモート）
GitHub / GitLab / Bitbucket などのホスティングサービスを「リモート」として登録してやり取りします。

## 初回の接続とプッシュ
```bash
# リモート登録（例）
git remote add origin https://github.com/<user>/<repo>.git

# デフォルトブランチを main に統一
git branch -M main

# 初回プッシュ（追跡ブランチ設定）
git push -u origin main
```

## 更新の取得と反映
```bash
# リモートの更新を取得
git fetch origin

# 作業ブランチに main の更新を取り込む（どちらか）
git merge origin/main        # マージで取り込み
# または
git rebase origin/main       # リベースで取り込み（履歴を直線化）

# main を更新（安全な引き込み）
git switch main
git pull --ff-only           # 予期せぬマージコミットを避ける
```

:::message alert
注意: 共有ブランチ（`main` など）への `--force` やリベースは避けましょう。公開履歴を書き換えると他メンバーに影響します。
:::

# プルリクエスト（PR）の実務フロー
1. 作業ブランチを切る
   ```bash
   git switch -c feature/awesome
   ```
2. 小さな論理単位でコミット
   ```bash
   git add -p
   git commit -m "Add awesome thing"
   ```
3. リモートへプッシュ（初回は追跡設定）
   ```bash
   git push -u origin feature/awesome
   ```
4. Gitサーバー上で PR を作成（base: main / compare: feature/awesome）
   - 説明、スクリーンショット、関連Issueを記載
   - CIが通るか確認
   - レビュアーに依頼
5. フィードバック対応（必要なら `git commit --fixup` や追加コミット）
6. マージ
   - チーム方針に合わせて「Squash merge」または「Merge commit」
7. 後片付け
   ```bash
   git switch main
   git pull --ff-only
   git branch -d feature/awesome
   git push origin --delete feature/awesome
   ```

## PR 前のセルフチェック（おすすめ）
- 差分の最終確認: `git diff main...HEAD`
- 履歴の見やすさ: `git log --oneline --graph --decorate`
- 余計なファイル: `.env` やビルド成果物が含まれていないか
